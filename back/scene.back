robotSerial "_bg_" leftOrRightArm + + "bg" store

( assumeBeeHome 1 changeToHeight waitUntilAtCurrentPosition
) "tempGoHome" store

( ( sceneUpdateObservedFromWrist  ( xUp ) 10 replicateWord waitUntilAtCurrentPosition comeToStop ) 5 replicateWord ) "sceneScanXUp" store
( ( sceneUpdateObservedFromWrist  ( xDown ) 10 replicateWord waitUntilAtCurrentPosition comeToStop ) 5 replicateWord ) "sceneScanXDown" store

( sceneScanXUp ( yUp ) 20 replicateWord sceneScanXDown ) "sceneScanLocal" store


(
  sceneClearPredictedObjects 0.26 0.795 1.5 sceneAddPredictedFocusedObject sceneClearObservedMap sceneUpdateObservedFromWrist 30 sceneSetBackgroundStdDev sceneComposePredictedMap sceneUpdateDiscrepancy sceneDensityFromDiscrepancy

60 20 fixCameraLightingExposureGain

0.5 sceneGrabDiscrepantCropAsClass
) "sceneRenderTest" store


( 
  sceneClearObservedMap 
  ( sceneUpdateObservedFromWrist ) 10 replicateWord 
  tempCaptureCore
) "tempCaptureAsFocused" store

( 
  sceneComposePredictedMap sceneUpdateDiscrepancy sceneDensityFromDiscrepancy 0.1 sceneGrabDiscrepantCropAsClass 
) "tempCaptureCore" store

(
  15.0 sceneSetBackgroundStdDevY
  11.0 sceneSetBackgroundStdDevColor
) "tempRegularizeBackground" store

( 
  bg sceneLoadBackgroundMap 
  5 sceneSetCellCountThreshold 
  tempRegularizeBackground

/* orion's left arm.
  10.0 sceneSetBackgroundStdDevY
  10.0 sceneSetBackgroundStdDevColor
  2 sceneSetCellCountThreshold 
*/
  sceneClearObservedMap sceneClearPredictedObjects 
) "tempInit" store

0.01 "scenePredictedMapThreshDefault" store
scenePredictedMapThreshDefault "scenePredictedMapThresh" store
(
  scenePredictedMapThresh sceneComposePredictedMapThreshed sceneUpdateDiscrepancy sceneDensityFromDiscrepancy  
) "tempUpdateMaps" store

(
  sceneClearObservedMap ( waitUntilImageCallbackReceived sceneUpdateObservedFromWrist ) 2 replicateWord tempUpdateMaps
) "tempShortTakeScene" store

(
  sceneClearObservedMap ( waitUntilImageCallbackReceived sceneUpdateObservedFromWrist ) 5 replicateWord tempUpdateMaps
) "tempLongTakeScene" store

(
  sceneClearObservedMap tempUpdateFivePointThreeWidth tempUpdateMaps
) "tempFivePointThreeWidthTakeScene" store

(
  sceneClearObservedMap tempUpdateSpiral tempUpdateMaps
) "tempSpiralTakeScene" store

0.1 "tempSpiralMoveSpeedDefault" store
tempSpiralMoveSpeedDefault "tempSpiralMoveSpeed" store
0.02 "tempSpiralGridSizeDefault" store
tempSpiralGridSizeDefault "tempSpiralGridSize" store
50 "tempSpiralStreamTakeSceneSamplesDefault" store
tempSpiralStreamTakeSceneSamplesDefault "tempSpiralStreamTakeSceneSamples" store
(
  rewindImageStreamBufferNLNK
  streamPushImageStreamSize tempSpiralStreamTakeSceneSamples divide "tempSpiralStreamTakeSceneStride" store
  ( sceneUpdateObservedFromStreamBuffer ( incrementImageStreamBufferNoLoadNoKick ) tempSpiralStreamTakeSceneStride replicateWord endStackCollapseNoop ) tempSpiralStreamTakeSceneSamples replicateWord
) "tempUpdateSpiralCoreIntegrate" store

(
  /* turn streaming on, no disk streaming */ 
  shutdownToSensorsAndMovement
  disableDiskStreaming

    /* Pose Range Image Joints Word Label */
    1 0 1 0 0 0 
  setSisFlags
  activateSensorStreaming

  /* spiral scan pattern */
  tempSpiralMoveSpeed setSpeed
  tempSpiralGridSize setGridSize
  shiftIntoGraspGear1 waitUntilAtCurrentPosition

  1 "tempUpdateSpiralIdx" store

  ( tempUpdateSpiralIdx tempUpdateSpiralN <  ) 
  ( ( xUp waitUntilAtCurrentPosition ) tempUpdateSpiralIdx replicateWord ( 0.2 waitForSeconds ) doUntilAtCurrentPosition 
    ( yUp waitUntilAtCurrentPosition ) tempUpdateSpiralIdx replicateWord ( 0.2 waitForSeconds ) doUntilAtCurrentPosition 
    ( xDown waitUntilAtCurrentPosition ) tempUpdateSpiralIdx 1 + replicateWord ( 0.2 waitForSeconds ) doUntilAtCurrentPosition 
    ( yDown waitUntilAtCurrentPosition ) tempUpdateSpiralIdx 1 + replicateWord ( 0.2 waitForSeconds ) doUntilAtCurrentPosition 
    "tempUpdateSpiralCoreNoClean" print
    tempUpdateSpiralIdx 2 + "tempUpdateSpiralIdx" store
  ) while

  /* turn streaming off */
  deactivateSensorStreaming
  bringUpAllNonessentialSystems
) "tempUpdateSpiralCoreNoClean" store

(
  "tempUpdateSpiralN" store
  currentPose "tempUpdateSpiralPos" store

  /* clear it all */
  sceneClearObservedMap
  clearStreamBuffers
  0.03 setW1GoThresh

  tempUpdateSpiralCoreNoClean

  /* integrate results */
  tempUpdateSpiralCoreIntegrate

  tempUpdateMaps

  quarterImpulse tempUpdateSpiralPos moveEeToPoseWord waitUntilAtCurrentPosition
) "tempUpdateSpiralCore" store

(
  /* turn streaming on, no disk streaming */ 
  shutdownToSensorsAndMovement
  disableDiskStreaming

    /* Pose Range Image Joints Word Label */
    1 0 1 0 0 0 
  setSisFlags
  activateSensorStreaming

  /* spiral scan pattern */
  tempSpiralMoveSpeed setSpeed
  tempSpiralGridSize setGridSize
  0.03 setW1GoThresh

  1 "tempUpdateSpiralIdx" store

  ( tempUpdateSpiralIdx tempUpdateSpiralN <  ) 
  ( ( xUp waitUntilAtCurrentPosition ) tempUpdateSpiralIdx tempUpdateSpiralXNum times replicateWord ( 0.2 waitForSeconds ) doUntilAtCurrentPosition 
    ( yUp waitUntilAtCurrentPosition ) tempUpdateSpiralIdx tempUpdateSpiralYNum times replicateWord ( 0.2 waitForSeconds ) doUntilAtCurrentPosition 
    ( xDown waitUntilAtCurrentPosition ) tempUpdateSpiralIdx tempUpdateSpiralXNum times 1 tempUpdateSpiralXNum times + replicateWord ( 0.2 waitForSeconds ) doUntilAtCurrentPosition 
    ( yDown waitUntilAtCurrentPosition ) tempUpdateSpiralIdx tempUpdateSpiralYNum times 1 tempUpdateSpiralYNum times + replicateWord ( 0.2 waitForSeconds ) doUntilAtCurrentPosition 
    "tempUpdateSpiralEccentricCore" print
    tempUpdateSpiralIdx 2 + "tempUpdateSpiralIdx" store
  ) while

  /* turn streaming off */
  deactivateSensorStreaming
  bringUpAllNonessentialSystems
) "tempUpdateSpiralEccentricCoreNoClean" store

(
  "tempUpdateSpiralN" store
  "tempUpdateSpiralYNum" store
  "tempUpdateSpiralXNum" store
  currentPose "tempUpdateSpiralPos" store

  /* clear it all */
  sceneClearObservedMap
  sceneClearPredictedObjects
  clearStreamBuffers
  0.03 setW1GoThresh

  tempUpdateSpiralEccentricCoreNoClean

  
  /* integrate results */
  tempUpdateSpiralCoreIntegrate

  tempUpdateMaps

  quarterImpulse tempUpdateSpiralPos moveEeToPoseWord waitUntilAtCurrentPosition
) "tempUpdateSpiralEccentricCore" store


(
  /* takes a string */
  tempLoadAndPrepareFocusedModel tempShortTakeScene scenePredictFocusedObject tempUpdateMaps
) "tempPredictAndRenderFile" store

(
  tempShortTakeScene scenePredictBestObject tempUpdateMaps
) "tempPredictAndRenderBest" store

(
  tempFivePointThreeWidthTakeScene scenePredictBestObject tempUpdateMaps
) "tempFivePointThreeWidthPredictAndRenderBest" store

(
  tempFivePointThreeWidthIsNewComponentNormalizedSumOfLogs
) "tempFivePointThreeWidthIsNewComponent" store

(
  numClasses 0 > (
    0.5 "tempNewComponentThresh" store
    sceneClearPredictedObjects
    sceneClearObservedMap

    tempFivePointThreeWidthTakeScene
    /*
    tempShortTakeScene
    */
    tempUpdateMaps endStackCollapseNoop 0.1 waitForSeconds
    /* pauseStackExecution */

    /*
	  scenePushTotalDiscrepancy 
    */
	  scenePushTotalDiscrepancyMagnitude 
	dup 
	"tempFivePointThreeWidthIsNewComponent: total discrepancy before " 
      swap + print 

    scenePredictBestObject tempUpdateMaps endStackCollapseNoop 0.1 waitForSeconds

    /*
	  scenePushTotalDiscrepancy 
    */
	  scenePushTotalDiscrepancyMagnitude 
	dup 
	"tempFivePointThreeWidthIsNewComponent: total discrepancy after " 
      swap + print 

	    swap
	  divide
	  dup
	"tempFivePointThreeWidthIsNewComponent: after / before ratio is " 
      swap + print

    tempNewComponentThresh > (
	    1
	  dup
	"tempFivePointThreeWidthIsNewComponent: IS a new component, returning " 
      swap + print
    ) (
	    0
	  dup
	"tempFivePointThreeWidthIsNewComponent: AIN'T a new component, returning " 
      swap + print
    ) ifte

	dup
      "tempFivePointThreeWidthIsNewComponent: returning " 
    swap + print
  ) (
    "tempFivePointThreeWidthIsNewComponent: numClasses is 0 so returning 1"
    1
  ) ifte

) "tempFivePointThreeWidthIsNewComponentBeforeAfter" store

(
  numClasses 0 > (
    0.15 "tempNewComponentThresh" store
    sceneClearPredictedObjects
    sceneClearObservedMap

    tempUpdateSpiral

    tempUpdateMaps endStackCollapseNoop 0.1 waitForSeconds

    /* pauseStackExecution */

    /*
	  scenePushTotalDiscrepancyMagnitude 
    */
	  scenePushTotalDiscrepancy 
	dup 
	"tempFivePointThreeWidthIsNewComponent: total discrepancy before " 
      swap + print 

    scenePredictBestObject tempUpdateMaps endStackCollapseNoop 0.1 waitForSeconds

    /*
	  scenePushTotalDiscrepancyMagnitude 
    */
	  scenePushTotalDiscrepancy 
	dup 
	"tempFivePointThreeWidthIsNewComponent: total discrepancy after " 
      swap + print 

    "tempFivePointThreeWidthIsNewComponentNormalizedSum_after" store
    "tempFivePointThreeWidthIsNewComponentNormalizedSum_before" store

      tempFivePointThreeWidthIsNewComponentNormalizedSum_before
      "tempFivePointThreeWidthIsNewComponent: total discrepancy before is " 
    swap + print


	tempFivePointThreeWidthIsNewComponentNormalizedSum_after
	tempFivePointThreeWidthIsNewComponentNormalizedSum_before
      +
    "tempFivePointThreeWidthIsNewComponentNormalizedSum_sum" store

      tempFivePointThreeWidthIsNewComponentNormalizedSum_sum
      "tempFivePointThreeWidthIsNewComponent: before after sum is" 
    swap + print
    


	tempFivePointThreeWidthIsNewComponentNormalizedSum_after
	tempFivePointThreeWidthIsNewComponentNormalizedSum_sum
      divide
    "tempFivePointThreeWidthIsNewComponentNormalizedSum_ratio" store

      tempFivePointThreeWidthIsNewComponentNormalizedSum_ratio
      "tempFivePointThreeWidthIsNewComponent: after / sum ratio is " 
    swap + print

      tempFivePointThreeWidthIsNewComponentNormalizedSum_ratio
      tempNewComponentThresh 
    > (
	    1
	  dup
	"tempFivePointThreeWidthIsNewComponent: IS a new component, returning " 
      swap + print
    ) (
	    0
	  dup
	"tempFivePointThreeWidthIsNewComponent: AIN'T a new component, returning " 
      swap + print
    ) ifte

	dup
      "tempFivePointThreeWidthIsNewComponent: returning " 
    swap + print
  ) (
      "tempFivePointThreeWidthIsNewComponent: numClasses is 0 so returning 1"
    print
    1
  ) ifte

) "tempSpiralIsNewComponentNormalizedSum" store


(
  numClasses 0 > (
    0.15 "tempNewComponentThresh" store
    sceneClearPredictedObjects

    tempUpdateMaps endStackCollapseNoop 0.1 waitForSeconds

    /* pauseStackExecution */

    /*
	  scenePushTotalDiscrepancyMagnitude 
    */
	  scenePushTotalDiscrepancy 
	dup 
	"tempSpiralIsNewComponentInPlace: total discrepancy before " 
      swap + print 

    scenePredictBestObject tempUpdateMaps endStackCollapseNoop 0.1 waitForSeconds

    /*
	  scenePushTotalDiscrepancyMagnitude 
    */
	  scenePushTotalDiscrepancy 
	dup 
	"tempSpiralIsNewComponentInPlace: total discrepancy after " 
      swap + print 

    "tempSpiralIsNewComponentInPlace_after" store
    "tempSpiralIsNewComponentInPlace_before" store

      tempSpiralIsNewComponentInPlace_before
      "tempSpiralIsNewComponentInPlace: total discrepancy before is " 
    swap + print


	tempSpiralIsNewComponentInPlace_after
	tempSpiralIsNewComponentInPlace_before
      +
    "tempSpiralIsNewComponentInPlace_sum" store

      tempSpiralIsNewComponentInPlace_sum
      "tempSpiralIsNewComponentInPlace: before after sum is" 
    swap + print
    


	tempSpiralIsNewComponentInPlace_after
	tempSpiralIsNewComponentInPlace_sum
      divide
    "tempSpiralIsNewComponentInPlace_ratio" store

      tempSpiralIsNewComponentInPlace_ratio
      "tempSpiralIsNewComponentInPlace: after / sum ratio is " 
    swap + print

      tempSpiralIsNewComponentInPlace_ratio
      tempNewComponentThresh 
    > (
	    1
	  dup
	"tempSpiralIsNewComponentInPlace: IS a new component, returning " 
      swap + print
    ) (
	    0
	  dup
	"tempSpiralIsNewComponentInPlace: AIN'T a new component, returning " 
      swap + print
    ) ifte

	dup
      "tempSpiralIsNewComponentInPlace: returning " 
    swap + print
  ) (
      "tempSpiralIsNewComponentInPlace: numClasses is 0 so returning 1"
    print
    1
  ) ifte

) "tempSpiralIsNewComponentInPlace" store

(
  numClasses 0 > (
	1.0
	1.20 
      divide
    "tempNewComponentThresh" store
    sceneClearPredictedObjects

    tempUpdateMaps endStackCollapseNoop 0.1 waitForSeconds

    /* pauseStackExecution */

	"tempSpiralIsNewComponentPseudoGeometricInPlace_tempScene"
	"_"
	leftOrRightArm 
	"_"
	robotSerial
      + + + +
      "tempSpiralIsNewComponentPseudoGeometricInPlace_tempSceneName"
    store


      tempSpiralIsNewComponentPseudoGeometricInPlace_tempSceneName
    sceneSaveFocusedSceneModel

    sceneClearPredictedObjects
    tempUpdateMaps
    tempCaptureCore

    sceneClearPredictedObjects 
    tempUpdateMaps

    scenePredictBestObject tempUpdateMaps endStackCollapseNoop 0.1 waitForSeconds

    /*
	  scenePushTotalDiscrepancy 
	  scenePushTotalDiscrepancyMagnitude 
	  scenePushTotalLogDiscrepancy
	  -10.00 scenePushTotalRelevantOneMinusDiscrepancy

	    scenePushFocusedClassModelArea
	    scenePushTotalDiscrepancy 
	  -

	    scenePushFocusedClassTotalDiscrepancy
	    scenePushTotalDiscrepancy 
	  -
    */
	    scenePushFocusedClassModelArea
	    scenePushTotalDiscrepancy 
	  -
	dup 
	"tempSpiralIsNewComponentPseudoGeometricInPlace: total discrepancy with new component" 
      swap + print 

      tempSpiralIsNewComponentPseudoGeometricInPlace_tempSceneName
    sceneLoadFocusedSceneModel

    sceneClearPredictedObjects 
    tempUpdateMaps

    scenePredictBestObject tempUpdateMaps endStackCollapseNoop 0.1 waitForSeconds

    /*
	  scenePushTotalDiscrepancy 
	  scenePushTotalDiscrepancyMagnitude 
	  scenePushTotalLogDiscrepancy
	  -10.00 scenePushTotalRelevantOneMinusDiscrepancy
    */
	    scenePushFocusedClassModelArea
	    scenePushTotalDiscrepancy 
	  -
	dup 
	"tempSpiralIsNewComponentPseudoGeometricInPlace: total discrepancy with best old component"
      swap + print 

    "tempSpiralIsNewComponentPseudoGeometricInPlace_after" store
    "tempSpiralIsNewComponentPseudoGeometricInPlace_before" store

      tempSpiralIsNewComponentPseudoGeometricInPlace_before
      "tempSpiralIsNewComponentPseudoGeometricInPlace: total discrepancy before is " 
    swap + print


	tempSpiralIsNewComponentPseudoGeometricInPlace_after
	tempSpiralIsNewComponentPseudoGeometricInPlace_before
      +
    "tempSpiralIsNewComponentPseudoGeometricInPlace_sum" store

      tempSpiralIsNewComponentPseudoGeometricInPlace_sum
      "tempSpiralIsNewComponentPseudoGeometricInPlace: before after sum is" 
    swap + print
    


	tempSpiralIsNewComponentPseudoGeometricInPlace_after
	tempSpiralIsNewComponentPseudoGeometricInPlace_sum
      divide
    "tempSpiralIsNewComponentPseudoGeometricInPlace_sum_ratio" store

      tempSpiralIsNewComponentPseudoGeometricInPlace_sum_ratio
      "tempSpiralIsNewComponentPseudoGeometricInPlace: old / sum ratio is " 
    swap + print

    
      tempSpiralIsNewComponentPseudoGeometricInPlace_before
      0.0
    equals (
      -1.0 "tempSpiralIsNewComponentPseudoGeometricInPlace_before" store
    ) ift

	tempSpiralIsNewComponentPseudoGeometricInPlace_after
	tempSpiralIsNewComponentPseudoGeometricInPlace_before
      divide
    "tempSpiralIsNewComponentPseudoGeometricInPlace_after_before_ratio" store

      tempSpiralIsNewComponentPseudoGeometricInPlace_after_before_ratio
      "tempSpiralIsNewComponentPseudoGeometricInPlace: old / new ratio (USING) is " 
    swap + print

      tempSpiralIsNewComponentPseudoGeometricInPlace_after_before_ratio
      tempNewComponentThresh 
    < (
	    1
	  dup
	"tempSpiralIsNewComponentPseudoGeometricInPlace: IS a new component, returning " 
      swap + print
    ) (
	    0
	  dup
	"tempSpiralIsNewComponentPseudoGeometricInPlace: AIN'T a new component, returning " 
      swap + print
    ) ifte

	dup
      "tempSpiralIsNewComponentPseudoGeometricInPlace: returning " 
    swap + print
  ) (
      "tempSpiralIsNewComponentPseudoGeometricInPlace: numClasses is 0 so returning 1"
    print
    1
  ) ifte

) "tempSpiralIsNewComponentPseudoGeometricInPlace" store

(
  numClasses 0 > (
    0.15 "tempNewComponentThresh" store
    sceneClearPredictedObjects
    sceneClearObservedMap

    /*
    tempFivePointThreeWidthTakeScene
    tempShortTakeScene
    */
    tempUpdateSpiralEccentric

    tempUpdateMaps endStackCollapseNoop 0.1 waitForSeconds
    /* pauseStackExecution */

    /*
	  scenePushTotalDiscrepancy 
	  scenePushTotalDiscrepancyMagnitude 
    */
	  scenePushTotalLogDiscrepancy
	  sceneTakeBeforeDensity
	dup 
	"tempFivePointThreeWidthIsNewComponent: total log discrepancy before " 
      swap + print 

    scenePredictBestObject tempUpdateMaps endStackCollapseNoop 0.1 waitForSeconds

    /*
	  scenePushTotalDiscrepancy 
	  scenePushTotalDiscrepancyMagnitude 
    */
	  scenePushTotalLogDiscrepancy
	  sceneTakeAfterDensity
	dup 
	"tempFivePointThreeWidthIsNewComponent: total log discrepancy after " 
      swap + print 

    "tempFivePointThreeWidthIsNewComponentNormalizedSum_after" store
    "tempFivePointThreeWidthIsNewComponentNormalizedSum_before" store

      tempFivePointThreeWidthIsNewComponentNormalizedSum_before
      "tempFivePointThreeWidthIsNewComponent: total discrepancy before is " 
    swap + print


	tempFivePointThreeWidthIsNewComponentNormalizedSum_after
	tempFivePointThreeWidthIsNewComponentNormalizedSum_before
      +
    "tempFivePointThreeWidthIsNewComponentNormalizedSum_sum" store

      tempFivePointThreeWidthIsNewComponentNormalizedSum_sum
      "tempFivePointThreeWidthIsNewComponent: before after sum is" 
    swap + print
    


	tempFivePointThreeWidthIsNewComponentNormalizedSum_after
	tempFivePointThreeWidthIsNewComponentNormalizedSum_sum
      divide
    "tempFivePointThreeWidthIsNewComponentNormalizedSum_ratio" store

      tempFivePointThreeWidthIsNewComponentNormalizedSum_ratio
      "tempFivePointThreeWidthIsNewComponent: after / sum ratio is " 
    swap + print

      tempFivePointThreeWidthIsNewComponentNormalizedSum_ratio
      tempNewComponentThresh 
    > (
	    1
	  dup
	"tempFivePointThreeWidthIsNewComponent: IS a new component, returning " 
      swap + print
    ) (
	    0
	  dup
	"tempFivePointThreeWidthIsNewComponent: AIN'T a new component, returning " 
      swap + print
    ) ifte

	dup
      "tempFivePointThreeWidthIsNewComponent: returning " 
    swap + print
  ) (
    "tempFivePointThreeWidthIsNewComponent: numClasses is 0 so returning 1"
    1
  ) ifte


   
      sceneHighPrecisionBeforeAfterDiffOfLogs
    "tempFivePointThreeWidthIsNewComponent: high precision diff " 
  swap + print

) "tempFivePointThreeWidthIsNewComponentNormalizedSumOfLogs" store

(
  /* takes a string */
  sceneLoadFocusedSceneModel 
) "tempLoadAndPrepareFocusedModel" store

(
  /* takes a scene object idx */

  tempMoveToSceneObject

  ( zDown ) 15 replicateWord
  ( oZUp ) 150 replicateWord
  ( localXUp ) 4 replicateWord

) "tempPointToSceneObject" store

(
  /* takes a scene object idx */
  1 changeToHeight

  

  scenePushNumSceneObjects 0 = 
  ( pop "tempMoveToSceneObject: no scene objects." print ) 
  ( 
    scenePushSceneObjectPose 
    currentPose 
      eePosePZ  
      setEEPosePZ 
      0 0 0 0 1.0 0 0 createEEPose 
      swap
    eePoseApplyRelativePoseTo 
    moveEeToPoseWord
  )
  ifte
) "tempMoveToSceneObject" store

(
  tempShortTakeScene tempServoToBestSceneObject
) "tempShortServoToBestSceneObject" store

(
  tempShortTakeScene tempServoToFocusedSceneObject
) "tempShortServoToFocusedSceneObject" store

(
  tempSpiralTakeScene tempServoToBestSceneObject
) "tempSpiralServoToBestSceneObject" store

(
  tempSpiralTakeScene tempServoToFocusedSceneObject
) "tempSpiralServoToFocusedSceneObject" store

/* internal */
(
  sceneClearPredictedObjects tempUpdateMaps scenePredictFocusedObject  tempUpdateMaps
  0 tempMoveToSceneObject
) "tempServoToFocusedSceneObject" store
(
  sceneClearPredictedObjects tempUpdateMaps scenePredictBestObject tempUpdateMaps
  0 tempMoveToSceneObject
) "tempServoToBestSceneObject" store
/* end internal */

(
  /* if you are in blocks, you will end up back in blocks. if not you will get whatever you had. */
  tempRestoreFromBlocks
  tempSwapToBlocks

  clearClassLabels
  initializeAndFocusOnTempClass
  tempRecaptureServoSpiral

  tempRestoreFromBlocks
) "tempSpiralServoToAnonymousObject" store

(
  /* if you are in blocks, you will end up back in blocks. if not you will get whatever you had. */
  tempRestoreFromBlocks
  tempSwapToBlocks

  tempSpiralServoToBestSceneObject

  tempRestoreFromBlocks
) "tempSpiralServoToBestBlock" store

(
/* demos relative transforms */

  /* this prints current pose */
      0 0 0 0 1.0 0 0 createEEPose 
      currentPose 0 0 0 0 1.0 0 0 createEEPose eePoseGetPoseRelativeTo 
    eePoseApplyRelativePoseTo
  print
    currentPose
  print

) "demoRelativeTransformations" store

(
  "scene" import tempInit assumeBeeHome 1 changeToHeight waitUntilAtCurrentPosition tempShortTakeScene 
  sceneClearPredictedObjects "brush" tempPredictAndRenderFile
  clearMapForPatrol clearBlueBoxMemories tempMapFocusedClass waitUntilAtCurrentPosition setMovementStateToMoving comeToStop tempMapFocusedClass deliverTargetObject
) "tempUsefulPhrases" store

(
  sceneClearPredictedObjects
  tempUpdateMaps
  tempCaptureCore

  sceneClearPredictedObjects 
  tempUpdateMaps
  tempServoToFocusedSceneObject
  waitUntilAtCurrentPosition
) "tempRecaptureServoInPlace" store
  
(
  tempRecaptureServoSpiral
) "tempRecaptureServo" store

(
  sceneClearPredictedObjects
  tempShortTakeScene
  tempCaptureCore

  tempShortServoToFocusedSceneObject
) "tempRecaptureServoShort" store

(
  sceneClearPredictedObjects
  sceneClearObservedMap tempUpdateSpiral tempUpdateMaps
  tempCaptureCore

  tempServoToFocusedSceneObject
) "tempRecaptureServoSpiral" store

(
  setMovementStateToMoving

  xUp
  yUp
  waitWord
  ( sceneUpdateObservedFromWrist ) 2 replicateWord
  
  yDown yDown
  waitWord
  ( sceneUpdateObservedFromWrist ) 2 replicateWord

  xDown xDown
  waitWord
  ( sceneUpdateObservedFromWrist ) 2 replicateWord

  yUp yUp
  waitWord
  ( sceneUpdateObservedFromWrist ) 2 replicateWord

  xUp
  yDown
  waitWord

  ( sceneUpdateObservedFromWrist ) 2 replicateWord
) "tempUpdateObservedFromWristFivePoint" store

( waitUntilRingBufferImageAtCurrentPosition setMovementStateToMoving comeToStop setMovementStateToMoving comeToStop ) "waitWord" store

(
  fullImpulse
  0.1 setGridSize xUp yUp waitUntilAtCurrentPosition setMovementStateToMoving comeToStop
  0.03 setSpeed
  ( yDown waitUntilAtCurrentPosition xDown xDown ( sceneUpdateObservedFromWrist 0.2 waitForSeconds ) doUntilAtCurrentPosition ) 2 replicateWord 
) "tempUpdateLawnmower" store

(
  "tempUpdateSpiral, pointing to another" print
  7 tempUpdateSpiralCore
) "tempUpdateSpiral" store

(
  0.05 setSpeed
  0.03 setW1GoThresh

  "tempUpdateSpiralN" store
  1 "tempUpdateSpiralIdx" store

  ( tempUpdateSpiralIdx tempUpdateSpiralN <  ) 
  ( ( xUp ) tempUpdateSpiralIdx replicateWord ( 0.2 waitForSeconds sceneUpdateObservedFromWrist  ) doUntilAtCurrentPosition 
    ( yUp ) tempUpdateSpiralIdx replicateWord ( 0.2 waitForSeconds sceneUpdateObservedFromWrist  ) doUntilAtCurrentPosition 
    ( xDown ) tempUpdateSpiralIdx 1 + replicateWord ( 0.2 waitForSeconds sceneUpdateObservedFromWrist  ) doUntilAtCurrentPosition 
    ( yDown ) tempUpdateSpiralIdx 1 + replicateWord ( 0.2 waitForSeconds sceneUpdateObservedFromWrist  ) doUntilAtCurrentPosition 
    "tempUpdateSpiralRing" print
    tempUpdateSpiralIdx 2 + "tempUpdateSpiralIdx" store
  ) while
) "tempUpdateSpiralRing" store

(
  0.05 setSpeed
  0.03 setW1GoThresh

  "tempUpdateSpiralN" store
  1 "tempUpdateSpiralIdx" store

  ( tempUpdateSpiralIdx tempUpdateSpiralN <  ) 
  ( ( xUp ) tempUpdateSpiralIdx replicateWord waitWord sceneUpdateObservedFromWrist
    ( yUp ) tempUpdateSpiralIdx replicateWord waitWord sceneUpdateObservedFromWrist
    ( xDown ) tempUpdateSpiralIdx 1 + replicateWord waitWord sceneUpdateObservedFromWrist
    ( yDown ) tempUpdateSpiralIdx 1 + replicateWord waitWord sceneUpdateObservedFromWrist
    "tempUpdateSpiralStop" print
    tempUpdateSpiralIdx 2 + "tempUpdateSpiralIdx" store
  ) while
) "tempUpdateSpiralStop" store



(
  currentPose 0.03 setGridSize tempUpdateObservedFromWristFivePoint eighthTurn 0.02 setGridSize tempUpdateObservedFromWristFivePoint eighthTurn 0.01 setGridSize tempUpdateObservedFromWristFivePoint moveEeToPoseWord
) "tempUpdateFivePointThreeWidth" store


(
  sceneClearObservedMap 
  waitUntilAtCurrentPosition
  9 tempUpdateSpiralCore tempUpdateMaps
  bg sceneSaveObservedMap 
  tempInit
) "tempUpdateBg" store


(
  zeroGOff
  setPlaceModeToHold setIdleModeToEmpty setBoundingBoxModeToMapping
  tenthImpulse 1 changeToHeight shiftIntoGraspGear1 waitUntilAtCurrentPosition

  initializeAndFocusOnNewClass

  ( tempRecaptureServo waitUntilAtCurrentPosition setMovementStateToMoving comeToStop ) 3 replicateWord

  sceneClearObservedMap sceneClearPredictedObjects 

  tempUpdateSpiral
  tempCaptureCore

  /* no additional scan */

  writeFocusedClass
) "tempQuickScan" store

(
  "tempFullScan: starting" print
  zeroGOff
  setPlaceModeToHold setIdleModeToEmpty setBoundingBoxModeToMapping
  tenthImpulse 1 changeToHeight shiftIntoGraspGear1 waitUntilAtCurrentPosition

  initializeAndFocusOnNewClass

  tempRecaptureServo 

  sceneClearObservedMap sceneClearPredictedObjects 

  tempUpdateSpiral
  tempCaptureCore

  1 waitSetCurrentWaitMode
  scanObjectScene
  0 waitSetCurrentWaitMode

  writeFocusedClass
) "tempFullScan" store

(
  /* needs an update */
  clearMapForPatrol

  lock3dGraspBase c3dPoseBase eePosePZ "tempScanBasePZ" store
  tempShortServoToFocusedSceneObject
  waitUntilAtCurrentPosition setMovementStateToMoving comeToStop
  tempShortServoToFocusedSceneObject
  waitUntilAtCurrentPosition setMovementStateToMoving comeToStop
  tempShortServoToFocusedSceneObject
  waitUntilAtCurrentPosition setMovementStateToMoving comeToStop
  currentPose tempScanBasePZ setEEPosePZ "tempScanBase" store

  scan_swapToBars
  gradientServo
  prepareForGraspFromMemory
  currentPose tempScanBasePZ pickFlushFactor + setEEPosePZ "tempScanNewGrasp" store
  scan_restoreFromBars

  tempScanBase setC3dPoseBase
  tempScanNewGrasp add3dGraspPoseWord
  writeFocusedClass
) "tempAddBarGrasp" store

(
  /* XXX if the number of classes is zero, how does this work out? */
  clearMapForPatrol

  lock3dGraspBase c3dPoseBase eePosePZ "tempScanBasePZ" store
  (
    tempSpiralServoToBestSceneObject
    quarterImpulse waitUntilAtCurrentPosition 
  ) 2 replicateWord
  currentPose tempScanBasePZ setEEPosePZ "tempScanBase" store

  tempSwapToBlocks 
  (
    tempSpiralServoToBestSceneObject
    quarterImpulse waitUntilAtCurrentPosition setMovementStateToMoving comeToStop
  ) 2 replicateWord
  quarterTurn /* this gets into orientation to pick so it will be saved next, since this is a block grasp */
  currentPose tempScanBasePZ pickFlushFactor + setEEPosePZ "tempScanNewGrasp" store
  tempRestoreFromBlocks 

  tempScanBase setC3dPoseBase
  tempScanNewGrasp add3dGraspPoseWord
  writeFocusedClass
) "tempAddBlockGrasp" store

(
  /* XXX if the number of classes is zero, how does this work out? */
  clearMapForPatrol

  lock3dGraspBase c3dPoseBase eePosePZ "tempScanBasePZ" store
  currentPose tempScanBasePZ setEEPosePZ "tempScanBase" store

  tempSwapToBlocks 
  sceneClearPredictedObjects 
  tempUpdateMaps
  tempServoToFocusedSceneObject
  waitUntilAtCurrentPosition setMovementStateToMoving comeToStop

  quarterTurn /* this gets into orientation to pick so it will be saved next, since this is a block grasp */
  currentPose tempScanBasePZ pickFlushFactor + setEEPosePZ "tempScanNewGrasp" store
  tempRestoreFromBlocks 

  tempScanBase setC3dPoseBase
  tempScanNewGrasp add3dGraspPoseWord
  writeFocusedClass

) "tempAddBlockGraspInPlace" store

(
/* XXX */ 
  /* this is meant to be run after a sufficiently broad and detailed scan and for the moment interacts with catScan5 variables */

  currentPose "catScan5Pos" store

  tempSpiralIsNewComponentPseudoGeometricInPlace (

    catScan5Pos moveEeToPoseWord waitUntilAtCurrentPosition

    /* tempFullScan */
    zeroGOff
    setPlaceModeToHold setIdleModeToEmpty setBoundingBoxModeToMapping
    tenthImpulse 1 changeToHeight shiftIntoGraspGear1 waitUntilAtCurrentPosition

    initializeAndFocusOnNewClass

    /* like recapture without taking a scene */
    tempRecaptureServoInPlace

    /* */
      currentPose 

      waitGetCurrentWaitMode
    1 waitSetCurrentWaitMode
    scanObjectScene
    waitSetCurrentWaitMode

    moveEeToPoseWord waitUntilAtCurrentPosition 
    writeFocusedClass
    /* */

    createCachedClassifierFromClassLabels
    trainAndWriteFocusedClassKnn

    clearClass3dGrasps
    writeFocusedClass

    /*
    tempAddBlockGrasp
    */
    tempAddBlockGraspInPlace
    /*
    */

    setPlaceModeToHold
    clearMapForPatrol

    setPickModeToLearningAlgorithmC
    tempMapBestAndPickInPlace
    writeFocusedClass

      playWorkspace 
    moveEeToPoseWord waitUntilAtCurrentPosition

    isGripperGripping (
      currentPose scan_gripperTouchTableZ setEEPosePZ moveEeToPoseWord
      quarterImpulse 0.01 setGridSize ( zUp ) catScan_dropHeight replicateWord setMovementStateToMoving comeToStop 
    ) ift
    openGripper
  ) (

    /* sets the target class */
    setPlaceModeToHold
    clearMapForPatrol

    /*
    tempAddBlockGrasp
    */
    tempAddBlockGraspInPlace
    /*
    */


    /* tempPickWithAddedGrasp */
    setPickModeToLearningAlgorithmC
    tempMapBestAndPickInPlace
    writeFocusedClass

    setGridSizeCoarse departureSpeed ( zUp ) 10 replicateWord setMovementStateToMoving comeToStop

    isGripperGripping (
      playWorkspace moveEeToPoseWord

      currentPose scan_gripperTouchTableZ setEEPosePZ moveEeToPoseWord
      quarterImpulse 0.01 setGridSize ( zUp ) catScan_dropHeight replicateWord setMovementStateToMoving comeToStop 
    ) ift
    openGripper
  ) ifte
) "tempAddBlockGraspSaveModelAndPickAfterFind" store

0 "tempBlockUsingBlocks" store
0.055 "tempBlockMaxGraspThickness" store
/*
0.04 "tempBlockGripperThrow" store
0.01 "tempBlockGraspResolution" store
*/
0.025 "tempBlockGripperThrow" store
0.005 "tempBlockGraspResolution" store
0.03 "tempBlockTargetContactWidth" store
(
  tempBlockUsingBlocks not (
    0.00 "scenePredictedMapThresh" store
    slide ( pushClassLabels 1 sP ) "tempSwapClassLabels" store
    focusedClassLabel "tempSwapTargetClass" store

    clearClassLabels 

    tempBlockMaxGraspThickness "thisBlockGraspThickness" store
    ( 
      tempBlockMaxGraspThickness thisBlockGraspThickness - tempBlockGripperThrow < 
      tempBlockMaxGraspThickness thisBlockGraspThickness - tempBlockGripperThrow = or
    ) ( 
      tempBlockTargetContactWidth thisBlockGraspThickness sceneFabricateIdealBlockModel 
      thisBlockGraspThickness tempBlockGraspResolution minus "thisBlockGraspThickness" store
    ) while

    setGraspModeTo3D
    0 sceneSetClassificationMode
    1 "tempBlockUsingBlocks" store
    "tempSwapToBlocks: swapped to blocks." print
  ) (
    clearClassLabels 

    tempBlockMaxGraspThickness "thisBlockGraspThickness" store
    ( 
      tempBlockMaxGraspThickness thisBlockGraspThickness - tempBlockGripperThrow < 
      tempBlockMaxGraspThickness thisBlockGraspThickness - tempBlockGripperThrow = or
    ) ( 
      tempBlockTargetContactWidth thisBlockGraspThickness sceneFabricateIdealBlockModel 
      thisBlockGraspThickness tempBlockGraspResolution minus "thisBlockGraspThickness" store
    ) while

    setGraspModeTo3D
    0 sceneSetClassificationMode
    1 "tempBlockUsingBlocks" store

    "tempSwapToBlocks: swapped to blocks but already holding blocks, not storing state." print    
  ) ifte
) "tempSwapToBlocks" store

(
  tempBlockUsingBlocks (
    "tempRestoreFromBlocks: restoring from blocks." print    

    scenePredictedMapThreshDefault "scenePredictedMapThresh" store
    endArgs tempSwapClassLabels setClassLabels 
    numClasses 0 > (
      tempSwapTargetClass setTargetClass
    ) (
      "Oops, restoring to ZERO classes!" print    
    ) ifte

    createCachedClassifierFromClassLabels
    setGraspModeTo3D
    1 sceneSetClassificationMode
    0 "tempBlockUsingBlocks" store
  ) (
    "tempRestoreFromBlocks: restoring from blocks but not holding blocks." print    
  ) ifte
) "tempRestoreFromBlocks" store

(
  0 sceneMapSceneObject
  recordPreTargetLock
  /* prepareForGraspFromMemory */
  recordPostTargetLock
  publishRecognizedObjectArrayFromBlueBoxMemory

  setGraspModeTo3D

  deliverTargetObject
) "tempPickWithAddedGrasp" store


/* consider deprecating or using */
(
  lock3dGraspBase c3dPoseBase eePosePZ "tempScanBasePZ" store
  tempShortServoToFocusedSceneObject
  waitUntilAtCurrentPosition setMovementStateToMoving comeToStop
  tempShortServoToFocusedSceneObject
  waitUntilAtCurrentPosition setMovementStateToMoving comeToStop
  tempShortServoToFocusedSceneObject
  waitUntilAtCurrentPosition setMovementStateToMoving comeToStop
  currentPose tempScanBasePZ setEEPosePZ "tempScanBase" store

  tempScanBase setC3dPoseBase
) "tempSceneLock3dGrasp" store


(
  ( tempShortServoToFocusedSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop ) 2 replicateWord

  0 sceneMapSceneObject
  recordPreTargetLock
  /* prepareForGraspFromMemory */
  recordPostTargetLock
  publishRecognizedObjectArrayFromBlueBoxMemory
) "tempMapFocusedClass" store

(
  /* entering tempMapBestClass */

  /* ( tempShortServoToBestSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop ) 2 replicateWord */

   ( tempSpiralServoToBestSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop ) 1 replicateWord 

  0 sceneMapSceneObject
  recordPreTargetLock
  /* prepareForGraspFromMemory */
  recordPostTargetLock
  publishRecognizedObjectArrayFromBlueBoxMemory
) "tempMapBestClass" store

(
  tempServoToBestSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop 

  0 sceneMapSceneObject
  recordPreTargetLock
  /* prepareForGraspFromMemory */
  recordPostTargetLock
  publishRecognizedObjectArrayFromBlueBoxMemory
) "tempMapBestClassInPlace" store

(
  openGripper waitUntilGripperNotMoving
  /*
  setGraspModeTo3D
  setIdleModeToEmpty
  setPlaceModeToShake 
  */

  clearMapForPatrol clearBlueBoxMemories tempMapFocusedClass deliverTargetObject
) "tempMapFocusedAndPick" store

(
  openGripper waitUntilGripperNotMoving
  /*
  setGraspModeTo3D
  setIdleModeToEmpty
  setPlaceModeToShake
  */

  clearMapForPatrol clearBlueBoxMemories tempMapBestClass 

  scenePushNumSceneObjects 0 > (
    "tempMapBestAndPick: delivering object..." print
      0 scenePushSceneObjectLabel 
    setTargetClass 
    deliverTargetObject
  ) (
    "tempMapBestAndPick: oops, no sceneObjects..." print
  ) ifte
) "tempMapBestAndPick" store

(
  openGripper waitUntilGripperNotMoving

  clearMapForPatrol clearBlueBoxMemories tempMapBestClassInPlace

  scenePushNumSceneObjects 0 > (
    "tempMapBestAndPick: delivering object..." print
      0 scenePushSceneObjectLabel 
    setTargetClass 
    deliverTargetObject
  ) (
    "tempMapBestAndPick: oops, no sceneObjects..." print
  ) ifte

) "tempMapBestAndPickInPlace" store

(
  /* endArgs "banana" "mediumClamp" "redScrewdriver" setClassLabels */
  /* endArgs "blueScrewdriver" "scissors" "wrench" setClassLabels */
  /* endArgs "scene_set_1/duplo" "scene_set_1/icraStandardDucky" "scene_set_1/lock" "scene_set_1/strawberry" setClassLabels */
  endArgs "scene_set_1/lock" setClassLabels

) "tempSetClassesSS1" store

(
  /* endArgs "banana" "mediumClamp" "redScrewdriver" setClassLabels */
  /* endArgs "blueScrewdriver" "scissors" "wrench" setClassLabels */
  /* endArgs "scene_set_1/duplo" "scene_set_1/icraStandardDucky" "scene_set_1/lock" "scene_set_1/strawberry" setClassLabels */
  /* endArgs "scene_set_1/lock" setClassLabels */
  /* endArgs "pond_duck" setClassLabels */
  /* endArgs "scissors_blue" setClassLabels */
  endArgs "narrow_duck_osp" setClassLabels

) "tempSetClassesSS2" store

(
  sceneClearPredictedObjects tempPredictAndRenderBest clearBlueBoxMemories 0 sceneMapSceneObject
) "tempClassifyOne" store

/* 
0.3883 "tempReconstructWithZTopZ" store 
*/
0.3983 "tempReconstructWithZTopZ" store 
0.20 "tempReconstructWithZTotalZ" store
0.005 "tempReconstructWithZDeltaZ" store
100 "tempReconstructStreamTakeSceneSamples" store
(
  sceneInitRegisterZero
  streamPushImageStreamSize tempReconstructStreamTakeSceneSamples divide "tempSpiralStreamTakeSceneStride" store

  tempReconstructWithZTopZ "tempReconstructWithZThisZ" store
  tempReconstructWithZTopZ tempReconstructWithZTotalZ - "tempReconstructWithZBottomZ" store

  sceneClearDepthStack

  ( tempReconstructWithZThisZ tempReconstructWithZBottomZ = 
    tempReconstructWithZThisZ tempReconstructWithZBottomZ > or ) 
  (
  
	  tempReconstructWithZBottomZ 
	" " 
	tempReconstructWithZThisZ	
	" " 
	tempReconstructWithZTopZ 
	" " 
      + + + + + print

    sceneClearObservedMap
    rewindImageStreamBufferNLNK 
    ( 
      tempReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalc 


      ( 
	incrementImageStreamBufferNoLoadNoKick 
      ) tempSpiralStreamTakeSceneStride replicateWord 

/*
      sceneRecalculateObservedMusAndSigmas
      sceneRenderObservedMap
*/

      endStackCollapseNoop 
    ) tempReconstructStreamTakeSceneSamples replicateWord

    sceneRecalculateObservedMusAndSigmas
    sceneRenderObservedMap
  
/*
    sceneSmoothSquaredCountsAndSamplesXY
    0.1 sceneTrimDepthWithDiscrepancy
*/

/*
      "zFigure_" tempReconstructWithZThisZ +
    sceneSaveScene

*/

      "high_zoom_figure_" tempReconstructWithZThisZ + 
    sceneSaveScene

/*
*/
    scenePushOntoDepthStack


/*
    sceneMinIntoRegister
*/

    tempReconstructWithZThisZ tempReconstructWithZDeltaZ - "tempReconstructWithZThisZ" store
  ) while



/*
  sceneMinDepthStackIntoRegister 
*/
  sceneMarginalizeDepthStackIntoRegister

  sceneRecallFromRegister 

  sceneRenderZ 
  sceneRenderObservedMap
) "tempReconstructWithZ" store

(
  quarterImpulse
  1 changeToHeight 
  shiftIntoGraspGear1
  waitUntilAtCurrentPosition

  /*
  0.001 setW1GoThresh
  0.020 "tempSpiralGridSize" store
  */
  0.005 setW1GoThresh
  /*
  0.0325 "tempSpiralGridSize" store
  */
  0.01625 "tempSpiralGridSize" store

90 setMapGrayBoxPixelSkirtRows 140 setMapGrayBoxPixelSkirtCols

  0.02 "tempSpiralMoveSpeed" store
  /* 0.008 "tempSpiralGridSize" store */

  /* 
  10 "tempReconstructStreamTakeSceneSamples" store
  playWorkspace moveEeToPoseWord 
  */

  12 "tempUpdateSpiralN" store
  currentPose "tempUpdateSpiralPos" store

  /* clear it all */
  sceneClearObservedMap
  clearStreamBuffers


  tempUpdateSpiralCoreNoClean tempUpdateMaps

  /* integrate results */
  /*
  tempUpdateSpiralCoreIntegrate
  */
  tempReconstructFromStream
  tempUpdateMaps

  quarterImpulse
  tempUpdateSpiralPos moveEeToPoseWord
  waitUntilAtCurrentPosition
) "tempReconstructTakeScene" store

(
  0.001 setW1GoThresh
  0.03 "tempSpiralMoveSpeed" store
  0.01 "tempSpiralGridSize" store
  6 tempUpdateSpiralCore tempUpdateMaps
) "tempReconstructTakeSceneMid" store

(
  "scene" import playWorkspace moveEeToPoseWord waitUntilAtCurrentPosition tempReconstructTakeScene 

  /* 
  catScan5LoadPlayBg tempUpdateMaps 0.1 sceneTrimDepthWithDiscrepancy sceneRenderZ
  3.0 sceneSmoothDepthStackInZ sceneInitRegisterMax sceneMinDepthStackIntoRegister sceneRecallFromRegister sceneRenderZ tempUpdateMaps
  */
) "tempReconstructPhrases" store

(
  tempReconstructWithZ 
  /* 
  3.0 sceneSmoothDepthStackInZ sceneInitRegisterMax sceneMinDepthStackIntoRegister sceneRecallFromRegister sceneRenderZ tempUpdateMaps
  */
) "tempReconstructFromStream" store

(
    "/home/aibo/catkin_ws/src/ein/default/objects/scene_eval_set"
  setClassLabelsObjectFolderAbsolute

  setPickModeToStaticMarginals
  setPlaceModeToHold

  (
      playWorkspace
    scan_findObjectAfterDrop
    tempMapBestAndPickInPlace

      playWorkspace
    moveEeToPoseWord waitUntilAtCurrentPosition
    0.05 perturbPositionScale waitUntilAtCurrentPosition

	"EVAL CLASSIFICATION " 
	focusedClassLabel
      +
    print

    0.04 setSpeed pressUntilEffortCombo openGripper liftArm
  ) 10 replicateWord
) "tempEvaluateObject" store


(
  tempReconstructTakeScene
  quarterImpulse
  tempServoToBestSceneObject
  pixelServoPutGripperUnderVanishingPoint waitUntilAtCurrentPosition 
) "tempReconstructServoToBestSceneObject" store


